{"root":{"data":{"text":"4 梯度下降的证明","note":"我们提出了梯度下降的证明（PoGD），这是一个基于 GKR 样式 Sumcheck 的证明，适用于一个小批量梯度下降迭代。"},"children":[{"data":{"text":"4.1 处理定点运算","note":"模型权重和数据项通常表示为实数，但我们需要将它们编码为域元素。我们选择一个足够大的域大小 \\( p \\) 以确保计算过程中不会溢出。我们将实数 \\( r \\) 量化为 \\( q \\)-位整数（\\( q \\ll p \\)），精度为 \\( f \\) 位，具体方法如下：当 \\( 0 \\leq r \\leq 2^{q-f} \\) 时，将 \\( r \\) 映射到 \\( s = \\lfloor r \\cdot 2^f \\rceil \\in F_p \\)，当 \\( -2^{q-f} \\leq r < 0 \\) 时，将 \\( r \\) 映射到 \\( s = p - \\lfloor r \\cdot 2^f \\rceil \\in F_p \\)。"},"children":[{"data":{"text":"整数算术和比较","note":"两个数字可以通过它们的量化值进行加法运算。对于数字 \\( a \\) 和 \\( b \\) 的乘法，其中 \\( s_a \\) 和 \\( s_b \\) 分别是它们的量化值，我们需要通过因子 \\( 2^{-f} \\) 来缩放 \\( z = s_a \\cdot s_b \\)。为此，我们要求证明者提供 \\( z_0, \\dots, z_{q-1} \\)，即 \\( z \\) 的位分解作为辅助输入，并附上符号位 \\( z_q \\)，其中 \\( z_q = 1 \\) 表示负数；验证者检查提供的位分解是否与 \\( z \\) 一致，并返回截断后的输出；即，如果 \\( z = (-1)^{z_q} \\sum_{i=0}^{q-1} z_i \\cdot 2^i \\)，则输出 \\( (-1)^{z_q} \\sum_{i=0}^{q-f-1} z_i \\cdot 2^i \\)。\n\n类似的技术可以用于比较。假设我们需要检查 \\( z \\geq 0 \\)，证明者可以提供 \\( z \\) 的位分解，包括符号位；验证者可以轻松检查这一点，比较的结果即为符号位。我们还可以处理除法运算。为了计算商 \\( a/b \\)，其中 \\( s_a \\) 和 \\( s_b \\) 是 \\( a \\) 和 \\( b \\) 的量化值，证明者提供商 \\( z \\) 和余数 \\( r \\)。验证者检查是否满足 \\( s_a = z \\cdot s_b + r \\) 且 \\( r < s_b \\)，然后返回 \\( z \\cdot 2^f \\) 作为输出。为了进一步减少电路大小，我们将每层的缩放因子进行累积，并将缩放操作推迟到 DNN 模型的输出层。"},"children":[]},{"data":{"text":"二进制运算的 Sumcheck","note":"缩放和位分解一致性检查可以通过域算术电路处理，并通过应用通用证明验证电路来验证。然而，对于复杂的模型，这类二进制运算会使电路和布线谓词的大小急剧增大。为了解决这个问题，我们将这些运算直接表示为 Sumcheck 实例。特别地，设 \\( \\mathcal{z} \\) 为一个 \\( n \\) 大小的向量，证明者需要提供其位分解。设 \\( \\mathcal{ZBit} \\) 为大小为 \\( n \\times q \\) 的矩阵，\\( \\mathcal{zSign} \\) 为大小为 \\( n \\) 的向量，其中 \\( \\mathcal{ZBit}[i, :] \\) 被声明为 \\( \\mathcal{z}[i] \\) 的位分解，\\( \\mathcal{zSign}[i] \\) 表示关联的符号位。为了检查 \\( \\mathcal{ZBit} \\) 和 \\( \\mathcal{zSign} \\) 是否为二进制，验证者发送挑战 \\( \\alpha, r_x, r_y \\)，并运行 Sumcheck 协议：\n\n\\[\n0 = \\sum_{x \\in \\{0,1\\}^{\\log n}, y \\in \\{0,1\\}^{\\log q}} \\beta_e(x, r_x) \\cdot \\beta_e(y, r_y) \\cdot (\\alpha \\cdot e_{\\mathcal{zSign}}(x) \\cdot (1 - e_{\\mathcal{zSign}}(x)) + \\mathcal{Z}eBit(x, y) \\cdot (1 - \\mathcal{Z}eBit(x, y)))\n\\]\n\n然后，验证者发送另一个挑战 \\( r_z \\)，各方通过运行 Sumcheck 验证位分解的一致性：\n\n\\[\ne_{\\mathcal{z}}(r_z) = \\sum_{x \\in \\{0,1\\}^{\\log n}, y \\in \\{0,1\\}^{\\log q}} \\beta_e(x, r_z) \\cdot \\mathcal{Z}eBit(x, y) \\cdot (1 - 2 \\cdot e_{\\mathcal{zSign}}(x)) \\cdot 2^y\n\\]\n\n我们可以类似地处理缩放问题。特别地，我们只需在式子中将 \\( x \\) 和 \\( y \\) 的范围限制在适当的区间内；\\( x \\) 的范围选择目标值并进行缩放，\\( y \\) 的范围决定应用的缩放因子。"},"children":[]},{"data":{"text":"指数运算","note":"自然指数运算用于 Softmax 和 tanh 等函数。在实践中，权重和数据项通常规范化到区间 [−1, 1]。类似于先前的工作 [34, 54]，我们使用以下分段近似来计算 \\( e^x \\)：\n\n\\[\ne^x \\approx\n\\begin{cases}\n0 & x < -1/2 \\\\\n1/2 + x & -1/2 \\leq x \\leq 1/2 \\\\\n1 & x > 1/2\n\\end{cases}\n\\]"},"children":[]},{"data":{"text":"4.2 我们的PoGD设计","note":"在PoGD中，证明者P使用数据批次 𝑩𝑖−1 更新权重 𝑾𝑖−1 到 𝑾𝑖（参考第2.3节中的梯度下降讨论）；PoGD使用sumcheck证明消息来向验证者V证明更新是正确的。为此，P使用多项式承诺方案向V提供算法的输入和输出（即𝑾e𝑖、𝑾e𝑖−1、𝑩e𝑖−1）以及辅助输入（例如位分解、商和余数）。注意，𝑾𝑖、𝑾𝑖−1 和AUX𝑖是𝑾𝑖,ℓ、𝑾𝑖−1,ℓ和AUX𝑖,ℓ的串联，涵盖所有层ℓ = 1到𝐿。\n\nPoGD的过程分为几个阶段。在第一个阶段，验证者验证算法的更新步骤；第二个阶段验证反向传播；第三个阶段验证正向传播。一旦生成了sumcheck消息，参与方会通过运行额外的sumcheck实例将不同阶段收到的输入和输出的随机评估组合起来。V使用其oracle访问权限验证最终评估。在处理线性操作时，参与方运行次线性sumcheck协议；对于非线性操作，他们运行通用的GKR证明（例如，Virgo++）。以下是PoGD四个阶段的简要描述。"},"children":[{"data":{"text":"阶段1：更新验证","note":"对于每一层ℓ = 1 到𝐿，V请求一个训练后的权重𝑾e𝑖,ℓ的随机评估。收到评估后，参与方运行GKR协议，验证𝑾𝑖,ℓ = 𝑾𝑖−1,ℓ−𝜂ℓ·𝑮𝑖,ℓ的更新，并最终得到𝑾e𝑖−1,ℓ和𝑮e𝑖,ℓ的随机评估。𝑾e𝑖−1,ℓ会进入阶段4，而𝑮e𝑖,ℓ进入阶段2，启动下一步的sumcheck。"},"children":[]},{"data":{"text":"阶段2：反向传播验证","note":"对于每一层ℓ = 1 到𝐿，基于阶段1中收到的𝑮e𝑖,ℓ评估和上一迭代中收到的𝑹e𝑖,ℓ（如果ℓ≠1），参与方验证式2。对于线性操作，使用次线性sumcheck协议；对于非线性操作，使用GKR协议验证输入的位分解；对于二元操作（例如缩放和一致性检查），使用sumcheck协议验证式3和式4。此阶段结束时，会得到𝑾e𝑖−1,ℓ、𝑼e𝑖,ℓ−1、𝑹e𝑖+1,ℓ和AUX𝑖,ℓ的评估，后者进入下一阶段。"},"children":[]},{"data":{"text":"阶段3：正向传播验证","note":"对于每一层ℓ = 𝐿 到 1，基于阶段2中收到的𝑼e𝑖,ℓ评估和上一迭代的评估（如果ℓ≠𝐿），参与方验证正向传播。线性操作使用次线性sumcheck协议，非线性操作使用GKR协议，缩放和一致性检查使用sumcheck协议。这一阶段结束时，会得到层输入的评估，包括𝑾e𝑖−1,ℓ、𝑼e𝑖,ℓ−1和AUX𝑖,ℓ。"},"children":[]},{"data":{"text":"阶段4：合并评估","note":"参与方将来自前几个阶段的所有评估（包括𝑾e𝑖−1, 𝑩e𝑖−1 和AUX𝑖）组合。在这一阶段，使用sumcheck协议将多项式𝑓的多个评估结果合并为一个评估。最终，验证者通过请求评估开销证明，检查这些评估。"},"children":[]}]},{"data":{"text":"安全性证明","note":"该PoGD协议满足完整性、知识安全性和零知识性。该构造的证明时间、证明大小和验证者时间是根据不同层的输入输出大小、批量大小和量化位数来计算的。我们使用Orion作为多项式承诺方案，因为它在具体实现中具有线性时间和高效的验证能力。通过递归组合PoGD，可以进一步减少验证成本。该协议也可以通过Fiat-Shamir启发式方法变为非交互式。\n\n---"},"children":[]},{"data":{"text":"关键点总结：","note":"1. **PoGD设计**：PoGD利用多阶段的sumcheck证明来验证梯度下降的每一部分操作，包括权重更新、反向传播和正向传播。\n   \n2. **阶段划分**：\n   - **阶段1**：验证权重更新。\n   - **阶段2**：验证反向传播步骤。\n   - **阶段3**：验证正向传播步骤。\n   - **阶段4**：通过sumcheck协议合并所有评估结果，并使用评估开销证明进行验证。\n\n3. **多项式承诺与优化**：通过多项式承诺方案和sumcheck协议，PoGD确保了证明的简洁性和验证的高效性。\n\n4. **性能与安全性**：协议的性能和安全性得到了保证，包括知识安全性、零知识性和完整性，且证明大小和验证时间可以通过递归优化来减小。"},"children":[]},{"data":{"text":"5.1 聚合评估","note":"我们首先回顾一种用于聚合单个多项式多个评估的技术 [36]。然后，我们展示如何将其推广到支持不同的多项式，并添加零知识特性。"},"children":[{"data":{"text":"单个多项式，多个点","note":"考虑到以下情况：𝑓₁ = ··· = 𝑓ₖ = 𝑓 且 𝜎₁ = ··· = 𝜎ₖ = 𝜎，但 {𝑥ᵢ} 是不同的。证明者和验证者插值一个度数为 (𝑘 − 1) 的单变量多项式 𝐿 : F → F，满足 𝐿(𝑖) = 𝑥ᵢ 对于所有 𝑖 ∈ {1, . . . , 𝑘} ⊆ F。证明者随后向验证者发送一个多项式 𝑔 = 𝑓 ◦ 𝐿，度数为 𝑂(𝑑𝑘ℓ)。验证者检查是否对所有 𝑖 : 𝑔(𝑖) = 𝑦ᵢ，然后，随机选择一个 𝑟 ∈ F，双方设定 𝑥* = 𝐿(𝑟) 和 𝑦* = 𝑔(𝑟)；此时，输出多项式和承诺为 𝑓* = 𝑓 和 𝜎* = 𝜎。\n\n我们声称，𝑓(𝑥*) = 𝑦* 当且仅当对于所有 𝑖 : 𝑓(𝑥ᵢ) = 𝑦ᵢ，以高概率为真。完整性是显而易见的。对于健全性，可以这样推理：假设 𝑓(𝑥₁) ≠ 𝑦₁。如果 𝑔 = 𝑓 ◦ 𝐿，则验证者会拒绝，因为 𝑔(1) ≠ 𝑦₁。如果 𝑔 ≠ 𝑓 ◦ 𝐿，那么 𝑔 和 𝑓 ◦ 𝐿 在最多 𝑂(𝑑𝑘ℓ) 个点上相等，因此我们有 𝑓(𝑥*) = 𝑦* 的概率是微乎其微的，最多为 𝑂(𝑑𝑘ℓ/|F|)。"},"children":[]},{"data":{"text":"多个多项式，多个点","note":"接下来，我们将上述思想扩展到多个（可能不同的）多项式 {𝑓ᵢ} 和点 {𝑥ᵢ} 的一般情况。如前所述，双方定义 𝐿 : F → F，使得对于所有 𝑖 : 𝐿(𝑖) = 𝑥ᵢ。然后，证明者发送 𝑘 个单变量多项式 𝑔ᵢ = 𝑓ᵢ ◦ 𝐿，验证者检查是否对所有 𝑖 : 𝑔ᵢ(𝑖) = 𝑦ᵢ。接着，对于随机挑战 {𝛼ᵢ} 和 𝑟，双方设定 𝑥* = 𝐿(𝑟)，𝑔 = Σ𝛼ᵢ𝑔ᵢ，且 𝑦* = 𝑔(𝑟)。输出多项式为 𝑓* = Σ𝛼ᵢ𝑓ᵢ；我们将承诺聚合的细节推迟到第5.2节，这部分称为承诺聚合。\n\n我们再次声称，𝑓(𝑥*) = 𝑦* 当且仅当对于所有 𝑖 : 𝑓(𝑥ᵢ) = 𝑦ᵢ，以高概率为真。完整性成立，因为：\n𝑓*(𝑥*) = (𝑓* ◦ 𝐿)(𝑟) = Σ𝛼ᵢ(𝑓ᵢ ◦ 𝐿)(𝑟) = Σ𝛼ᵢ𝑔ᵢ(𝑟) = 𝑔(𝑟)。\n\n对于健全性，如果存在某个 𝑓ᵢ(𝑥ᵢ) ≠ 𝑦ᵢ，证明者必须发送 𝑔ᵢ ≠ 𝑓ᵢ ◦ 𝐿 才能通过验证。然而，在选择随机挑战 {𝛼ᵢ} 和 𝑟 时，以高概率我们有 𝑦 = 𝑔(𝑟) ≠ (𝑓* ◦ 𝐿)(𝑟) = 𝑓*(𝑥*)。"},"children":[]},{"data":{"text":"线性时间证明者","note":"对每个多项式 𝑔ᵢ 进行插值的直接方法会使得证明者的成本为 𝑂(𝑑𝑘ℓ · 2ℓ)，因为它需要在 𝑂(𝑑𝑘ℓ) 个点上评估一个大小为 𝑂(2ℓ) 的多项式 𝑓ᵢ。幸运的是，我们可以通过递归插值方法实现线性时间证明者。定义 𝑃𝑗 : F → F 的度数为 𝑂(𝑑𝑘ℓ)，使得 𝑃𝑗(𝑖) 输出每个 𝑥ᵢ 的第 𝑗 个变量。我们观察到 𝑔ᵢ = (1 − 𝑃₁)(𝑓ᵢ(0, 𝑥₂, ..., 𝑥ℓ) ◦ 𝐿) + 𝑃₁(𝑓ᵢ(1, 𝑥₂, ..., 𝑥ℓ) ◦ 𝐿)，因此证明者可以将 𝑔ᵢ 的插值简化为插值 𝑓ᵢ(0, 𝑥₂, ..., 𝑥ℓ) ◦ 𝐿 和 𝑓ᵢ(1, 𝑥₂, ..., 𝑥ℓ) ◦ 𝐿，这可以在 𝑂(2ℓ−1) 时间内完成。接着，𝑔ᵢ 可以在 𝑂(𝑑𝑘ℓ) 的额外时间内进行评估。这个过程可以递归应用到简化后的插值上，从而实现线性时间（即 𝑂(2ℓ)）的总体插值开销。"},"children":[]},{"data":{"text":"零知识","note":"在讨论承诺聚合之前，我们简要讨论如何通过掩码多项式使上述思想具备零知识性。对于所有 𝑖，证明者随机采样一个 ℓ 变量多项式 ℎᵢ，并发送对 ℎᵢ 的承诺 𝜎′ᵢ 以及评估值 𝑣ᵢ = ℎᵢ(𝑥ᵢ)。给定随机挑战 {𝛽ᵢ}，对于所有 𝑖，证明者然后发送 𝑔ᵢ = (𝑓ᵢ + 𝛽ᵢℎᵢ) ◦ 𝐿，验证者检查 𝑔(𝑖) = 𝑦ᵢ + 𝛽ᵢ𝑣ᵢ。协议的其余部分与上述相似；此时，输出多项式为 𝑓* = Σ𝛼ᵢ𝑓ᵢ + 𝛼ᵢ𝛽ᵢℎᵢ。\n\n在实际应用中，简单地选择每个 ℎᵢ 作为一个随机 ℓ 变量多项式，其最大变量度数为 𝑑 会使得每个 ℎᵢ 的系数数量达到 𝑂(𝑑ℓ)，这样会导致效率低下。我们在附录 C 中展示，只需将每个 ℎᵢ 采样为 ℎᵢ = Σℓ𝑗=1ℎᵢ,𝑗，其中每个 ℎᵢ,𝑗 是一个随机单变量多项式（在第 𝑗 个变量中的度数为 𝑑ℓ）。每个 ℎᵢ 的大小为 𝑂(𝑑ℓ²)，而零知识的成本为 𝑂(𝑘𝑑ℓ²)。"},"children":[]}]},{"data":{"text":"5.2 聚合承诺","note":"接下来需要展示如何在给定承诺{𝜎𝑖}（即对{𝑓𝑖}的承诺）的情况下，计算出对𝑓∗ = ∑𝑖 𝛼𝑖 𝑓𝑖的承诺𝜎∗。该过程自然扩展到零知识证明方案，其中𝑓∗ = ∑𝑖 𝛼𝑖 𝑓𝑖 + 𝛼𝑖 𝛽𝑖ℎ𝑖，且各方还持有{𝜎′𝑖}。当然，如果底层承诺方案是同态的，那么承诺聚合就是微不足道的。然而，已知的实际同态承诺方案（如[20, 41, 60]）主要基于群体假设，且无法高效地用于递归证明组合。在我们的应用中，我们使用Orion [63]，这是一种基于Merkle树的承诺方案，它并不是同态的。我们描述了如何在该方案中承诺输入多项式的线性组合。尽管讨论特定于Orion，但该技术可以扩展到其他基于哈希的方案[7, 66]。"},"children":[{"data":{"text":"Orion概述","note":"我们简要回顾Orion方案。在该方案中，多项式的系数被映射到一个平方矩阵𝑴中，矩阵大小为𝑛 × 𝑛。然后，应用一个线性错误纠正码𝐸 : Fⁿ → Fᵖ对矩阵𝑴进行两次编码。首先，应用该码对𝑴的每一行进行编码，得到一个𝑛×𝑝的矩阵𝑪₁。然后，再对𝑪₁的每一列应用该码，得到一个𝑝×𝑝的矩阵𝑪₂。证明者计算每一列的Merkle根，然后将这𝑝个根计算得到的Merkle根作为对多项式的承诺。\n\n验证者通过发送一个随机向量𝒓 ∈ Fⁿ以及𝑡 = Θ(𝜆)个随机索引（在[𝑝]范围内）来检查承诺的正确性。证明者回应一个向量𝒗 = 𝒓ᵀ · 𝑴，并返回𝑡个随机列𝑪₁以及这些列的Merkle证明。验证者执行以下步骤：\n\n1. 计算码字𝒘 = 𝐸(𝒗)；\n2. 对于每个挑战索引𝑖，验证返回的列𝑪₁[:,𝑖]是否满足𝒘ᵢ = 𝒓ᵀ · 𝑪₁[:,𝑖]；\n3. 验证所有Merkle证明的正确性。\n\n评估证明也可以类似地生成，但我们省略了细节。Orion通过随机编码和将上述验证过程与通用简洁零知识证明[66]组合来实现零知识和简洁性。"},"children":[]},{"data":{"text":"Orion的聚合","note":"假设验证者持有承诺{𝜎𝑖}，这些承诺对应于证明者已知的多项式{𝑓𝑖}，并且让𝑴𝑖、𝑪𝑖₁、𝑪𝑖₂是证明者在对𝑓𝑖进行承诺时生成的相应矩阵。证明者生成对𝑓∗ = ∑𝛼𝑖 𝑓𝑖的承诺𝜎∗并发送给验证者；让𝑴∗、𝑪∗₁、𝑪∗₂是这一过程中的相应矩阵。对于一个诚实的证明者，𝑴∗ = ∑𝛼𝑖𝑴𝑖，𝑪∗₁ = ∑𝛼𝑖𝑪𝑖₁，𝑪∗₂ = ∑𝛼𝑖𝑪𝑖₂。\n\n另一方面，如果𝑴∗ ≠ ∑𝛼𝑖𝑴𝑖，则令𝛿为错误纠正码𝐸的最小距离，那么矩阵𝑪∗₂和∑𝛼𝑖𝑪𝑖₂至少在𝛿²个条目上有所不同。一个关键观察是，除了检查承诺𝜎∗的正确性，验证者还可以检查𝑪∗₂和{𝑪𝑖₂}中随机条目的正确线性关系；如果𝐸具有常量相对距离，则只需检查对每个𝑪∗₂和{𝑪𝑖₂}的Θ(𝜆)个随机打开条目的线性组合关系是否成立。\n\n我们在协议4中提供了更正式的细节，并在附录C中证明了我们聚合方案的安全性。"},"children":[]},{"data":{"text":"定理 2","note":"协议4中提出的聚合方案满足完整性、知识健壮性和零知识性。证明者的计算开销主要由生成承诺𝜎∗（其复杂度为𝑂(𝑑ℓ)）和评估{𝑔𝑖}（其复杂度为𝑂(𝑘·𝑑ℓ)）主导。证明大小主要由Merkle证明决定，大小为𝑂(𝑘𝑑ℓ)；这也是验证者的复杂度。该方案可以通过Fiat-Shamir使其非交互式。"},"children":[]}]}]}]},"template":"default","theme":"fresh-blue","version":"1.4.43"}